import for_mathlib.algebra.homology.mapping_cone
import algebra.homology.additive
import for_mathlib.category_theory.triangulated.pretriangulated_misc

open category_theory category_theory.pretriangulated category_theory.triangulated
  category_theory.limits

noncomputable theory

section

variables {C Œπ : Type*} [category C] [preadditive C] {c : complex_shape Œπ}

def homotopy_category.lift {K L : homological_complex C c}
  (œÜ : (homotopy_category.quotient _ _).obj K ‚ü∂ (homotopy_category.quotient _ _).obj L) :
  K ‚ü∂ L := quot.out œÜ

instance [has_zero_object C] : has_zero_object (homotopy_category C c) :=
by { change has_zero_object (category_theory.quotient _), apply_instance, }

instance : preadditive (homotopy_category C c) :=
begin
  apply quotient.preadditive,
  { rintros X Y f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ ‚ü®h‚ÇÅ‚ü© ‚ü®h‚ÇÇ‚ü©,
    refine ‚ü®homotopy.add h‚ÇÅ h‚ÇÇ‚ü©, },
  { rintros X Y f g ‚ü®h‚ü©,
    exact ‚ü®homotopy.equiv_sub_zero.symm
      (by simpa only [neg_sub_neg] using homotopy.equiv_sub_zero h.symm)‚ü©, },
end

instance homotopy_category.quotient_additive :
  (homotopy_category.quotient C c).additive := quotient.functor_additive _ _ _

lemma is_zero_of_homotopy_id_zero [has_zero_object C] (X : homological_complex C c)
  (h : homotopy (ùüô X) 0) :
  is_zero ((homotopy_category.quotient C c).obj X) :=
begin
  have eq := homotopy_category.eq_of_homotopy _ _ h,
  simp only [category_theory.functor.map_id] at eq,
  simp only [is_zero.iff_id_eq_zero, eq, functor.map_zero],
end

end

variables {C : Type*} [category C] [preadditive C] [has_zero_object C]
  [has_binary_biproducts C]
  {K L : cochain_complex C ‚Ñ§} (œÜ : K ‚ü∂ L)

namespace cochain_complex


@[simps mor‚ÇÅ mor‚ÇÇ mor‚ÇÉ]
def mapping_cone_triangle : triangle (cochain_complex C ‚Ñ§) :=
triangle.mk œÜ (Œπ_mapping_cone œÜ) (mapping_cone_Œ¥ œÜ)

end cochain_complex

open cochain_complex

namespace homotopy_category

def mapping_cone_triangle' : triangle (homotopy_category C (complex_shape.up ‚Ñ§)) :=
triangle.mk ((homotopy_category.quotient _ _).map œÜ) (Œπ_mapping_cone' œÜ) (mapping_cone_Œ¥' œÜ)

variable (C)

def distinguished_triangles : set (triangle (homotopy_category C (complex_shape.up ‚Ñ§))) :=
Œª T, ‚àÉ (K L : cochain_complex C ‚Ñ§) (œÜ : K ‚ü∂ L),
  nonempty (T ‚âÖ mapping_cone_triangle' œÜ)

variable {C}

lemma mapping_cone_triangle'_distinguished :
  mapping_cone_triangle' œÜ ‚àà distinguished_triangles C :=
‚ü®_, _, œÜ, nonempty.intro (iso.refl _)‚ü©

instance shift_functor_additive (n : ‚Ñ§) :
  (shift_functor (homotopy_category C (complex_shape.up ‚Ñ§)) n).additive := sorry

lemma isomorphic_distinguished
  (T‚ÇÅ : triangle (homotopy_category C (complex_shape.up ‚Ñ§)))
  (h‚ÇÅ : T‚ÇÅ ‚àà distinguished_triangles C)
  (T‚ÇÇ : triangle (homotopy_category C (complex_shape.up ‚Ñ§)))
  (e : T‚ÇÇ ‚âÖ T‚ÇÅ) : T‚ÇÇ ‚àà distinguished_triangles C :=
begin
  obtain ‚ü®K, L, œÜ, ‚ü®e'‚ü©‚ü© := h‚ÇÅ,
  exact ‚ü®K, L, œÜ, ‚ü®e ‚â™‚â´ e'‚ü©‚ü©,
end

lemma contractible_distinguished
  (X : homotopy_category C (complex_shape.up ‚Ñ§)) :
  contractible_triangle X ‚àà distinguished_triangles C :=
begin
  cases X,
  refine ‚ü®_, _, ùüô X, ‚ü®_‚ü©‚ü©,
  have h : is_zero ((homotopy_category.quotient _ _).obj (mapping_cone (ùüô X))),
  { refine is_zero_of_homotopy_id_zero _ _,
    equiv_rw hom_complex.equiv_homotopy _ _,
    refine ‚ü®_, sorry‚ü©,
    sorry, },
  exact triangle.mk_iso _ _ (iso.refl _) (iso.refl _) (is_zero.iso_zero h).symm
    (by tidy) (is_zero.eq_of_tgt h _ _) (by simp only [is_zero.eq_of_src h
      ((mapping_cone_triangle' (ùüô X)).mor‚ÇÉ) 0, contractible_triangle_mor‚ÇÉ, zero_comp, comp_zero]),
end

lemma distinguished_cocone_triangle
  (X Y : homotopy_category C (complex_shape.up ‚Ñ§)) (f : X ‚ü∂ Y) :
  ‚àÉ (Z : homotopy_category C (complex_shape.up ‚Ñ§)) (g : Y ‚ü∂ Z)
    (h : Z ‚ü∂ X‚ü¶(1 : ‚Ñ§)‚üß), triangle.mk f g h ‚àà distinguished_triangles C :=
begin
  cases X,
  cases Y,
  obtain ‚ü®œÜ, rfl‚ü© := quotient.functor_map_surjective _ _ f,
  exact ‚ü®_ ,_ ,_ , mapping_cone_triangle'_distinguished œÜ‚ü©,
end

lemma complete_distinguished_triangle_morphism'
  {K‚ÇÅ L‚ÇÅ K‚ÇÇ L‚ÇÇ : cochain_complex C ‚Ñ§} (œÜ‚ÇÅ : K‚ÇÅ ‚ü∂ L‚ÇÅ) (œÜ‚ÇÇ : K‚ÇÇ ‚ü∂ L‚ÇÇ)
  (a : K‚ÇÅ ‚ü∂ K‚ÇÇ) (b : L‚ÇÅ ‚ü∂ L‚ÇÇ) (hab : homotopy (œÜ‚ÇÅ ‚â´ b) (a ‚â´ œÜ‚ÇÇ)) :
  ‚àÉ (c : mapping_cone œÜ‚ÇÅ ‚ü∂ mapping_cone œÜ‚ÇÇ),
    nonempty (homotopy (Œπ_mapping_cone œÜ‚ÇÅ ‚â´ c) (b ‚â´ Œπ_mapping_cone œÜ‚ÇÇ)) ‚àß
      nonempty (homotopy (mapping_cone_Œ¥ œÜ‚ÇÅ ‚â´ a‚ü¶1‚üß') (c ‚â´ mapping_cone_Œ¥ œÜ‚ÇÇ)) := sorry

lemma complete_distinguished_triangle_morphism
  (T‚ÇÅ T‚ÇÇ : triangle (homotopy_category C (complex_shape.up ‚Ñ§)))
  (h‚ÇÅ : T‚ÇÅ ‚àà distinguished_triangles C) (h‚ÇÇ : T‚ÇÇ ‚àà distinguished_triangles C)
  (a : T‚ÇÅ.obj‚ÇÅ ‚ü∂ T‚ÇÇ.obj‚ÇÅ) (b : T‚ÇÅ.obj‚ÇÇ ‚ü∂ T‚ÇÇ.obj‚ÇÇ)
  (comm‚ÇÅ : T‚ÇÅ.mor‚ÇÅ ‚â´ b = a ‚â´ T‚ÇÇ.mor‚ÇÅ) :
  ‚àÉ (c : T‚ÇÅ.obj‚ÇÉ ‚ü∂ T‚ÇÇ.obj‚ÇÉ), T‚ÇÅ.mor‚ÇÇ ‚â´ c = b ‚â´ T‚ÇÇ.mor‚ÇÇ ‚àß
    T‚ÇÅ.mor‚ÇÉ ‚â´ a‚ü¶(1 : ‚Ñ§)‚üß' = c ‚â´ T‚ÇÇ.mor‚ÇÉ :=
begin
  obtain ‚ü®K‚ÇÅ, L‚ÇÅ, œÜ‚ÇÅ, ‚ü®e‚ÇÅ‚ü©‚ü© := h‚ÇÅ,
  obtain ‚ü®K‚ÇÇ, L‚ÇÇ, œÜ‚ÇÇ, ‚ü®e‚ÇÇ‚ü©‚ü© := h‚ÇÇ,
  obtain ‚ü®c, ‚ü®h‚ÇÅ‚ü©, ‚ü®h‚ÇÇ‚ü©‚ü© := complete_distinguished_triangle_morphism' œÜ‚ÇÅ œÜ‚ÇÇ
    (quot.out (e‚ÇÅ.inv.hom‚ÇÅ ‚â´ a ‚â´ e‚ÇÇ.hom.hom‚ÇÅ)) (quot.out (e‚ÇÅ.inv.hom‚ÇÇ ‚â´ b ‚â´ e‚ÇÇ.hom.hom‚ÇÇ))
    (homotopy_of_eq _ _ begin
      simp only [functor.map_comp, quotient_map_out, category.assoc],
      erw [reassoc_of e‚ÇÅ.inv.comm‚ÇÅ, reassoc_of comm‚ÇÅ, e‚ÇÇ.hom.comm‚ÇÅ],
      refl,
    end),
  replace h‚ÇÅ := eq_of_homotopy _ _ h‚ÇÅ,
  replace h‚ÇÇ := eq_of_homotopy _ _ h‚ÇÇ,
  refine ‚ü®e‚ÇÅ.hom.hom‚ÇÉ ‚â´ (homotopy_category.quotient _ _).map c ‚â´ e‚ÇÇ.inv.hom‚ÇÉ, _, _‚ü©,
  { simp only [functor.map_comp, quotient_map_out, category.assoc] at h‚ÇÅ,
    erw [reassoc_of e‚ÇÅ.hom.comm‚ÇÇ, reassoc_of h‚ÇÅ, e‚ÇÇ.inv.comm‚ÇÇ],
    simp only [triangle.hom_inv_id_hom‚ÇÇ_assoc], },
  { erw [functor.map_comp, quotient_map_shift] at h‚ÇÇ,
    simp only [quotient_map_out, functor.map_comp] at h‚ÇÇ,
    simp only [category.assoc, ‚Üê e‚ÇÇ.inv.comm‚ÇÉ],
    erw [‚Üê reassoc_of h‚ÇÇ, ‚Üê reassoc_of e‚ÇÅ.hom.comm‚ÇÉ],
    simp only [‚Üê functor.map_comp, triangle.hom_inv_id_hom‚ÇÅ, category.comp_id,
      triangle.hom_inv_id_hom‚ÇÅ_assoc], },
end

instance : pretriangulated (homotopy_category C (complex_shape.up ‚Ñ§)) :=
{ distinguished_triangles := distinguished_triangles C,
  isomorphic_distinguished := isomorphic_distinguished,
  contractible_distinguished := contractible_distinguished,
  distinguished_cocone_triangle := distinguished_cocone_triangle,
  rotate_distinguished_triangle := sorry,
  complete_distinguished_triangle_morphism :=
    complete_distinguished_triangle_morphism, }

end homotopy_category
