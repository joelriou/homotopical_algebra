/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import category_theory.localization.basic
import algebraic_topology.homotopical_algebra.model_category
import category_theory.quotient
import category_theory.path_category
import category_theory.category.Quiv

open category_theory
open category_theory.category

namespace category_theory

universes v v' u u'

variables {C : Type u} [category.{v} C] (W : hom_class C)

include W

structure preloc := (as : C)

instance : quiver.{v+1} (preloc W) := { hom := Œª A B,  (A.as ‚ü∂ B.as) ‚äï (W B.as A.as) }

variable (W)

def R‚ÇÅ := Œ£ (T : C √ó C √ó C), (T.1 ‚ü∂ T.2.1) √ó (T.2.1 ‚ü∂ T.2.2)
def R‚ÇÇ := Œ£ (T : C √ó C), (W T.1 T.2 : Type v)
def R‚ÇÉ := R‚ÇÇ W
def œÅ‚ÇÅ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : R‚ÇÅ W := ‚ü®‚ü®X, ‚ü®Y, Z‚ü©‚ü©, ‚ü®f, g‚ü©‚ü©
def œÅ‚ÇÇ‚ÇÉ {X Y : C} (g : X ‚ü∂ Y) (hg : W X Y g) : R‚ÇÇ W := ‚ü®‚ü®X,Y‚ü©, ‚ü®g, hg‚ü©‚ü©

def F := Œ£ (D : paths (preloc W) √ó paths (preloc W)), (D.1 ‚ü∂ D.2) √ó (D.1 ‚ü∂ D.2)

def œÜ (X : C) : paths (preloc W) := paths.of.obj { as := X }

def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : œÜ W X ‚ü∂ œÜ W Y := paths.of.map (sum.inl f)
def œà‚ÇÇ {X Y : C} (g : X ‚ü∂ Y) (hg : W X Y g): œÜ W Y ‚ü∂ œÜ W X := paths.of.map (sum.inr ‚ü®g, hg‚ü©)

def relations‚ÇÄ : C ‚Üí F W := by { intro X, exact ‚ü®‚ü®‚ü®X‚ü©, ‚ü®X‚ü©‚ü©, ‚ü®œà‚ÇÅ W (ùüô _), ùüô _‚ü©‚ü©, }
def relations‚ÇÅ : R‚ÇÅ W ‚Üí F W :=
by { rintro ‚ü®‚ü®X,‚ü®Y,Z‚ü©‚ü©, ‚ü®f,g‚ü©‚ü©, exact ‚ü®‚ü®‚ü®X‚ü©, ‚ü®Z‚ü©‚ü©, ‚ü®œà‚ÇÅ W (f ‚â´ g), œà‚ÇÅ W f ‚â´ œà‚ÇÅ W g‚ü©‚ü©, }
def relations‚ÇÇ : R‚ÇÇ W ‚Üí F W :=
by { rintro ‚ü®‚ü®X, Y‚ü©, ‚ü®w, hw‚ü©‚ü©, exact ‚ü®‚ü®‚ü®X‚ü©, ‚ü®X‚ü©‚ü©, ‚ü®œà‚ÇÅ W w ‚â´ œà‚ÇÇ W w hw, ùüô _‚ü©‚ü©, }
def relations‚ÇÉ : R‚ÇÉ W ‚Üí F W :=
by { rintro ‚ü®‚ü®X, Y‚ü©, ‚ü®w, hw‚ü©‚ü©, exact ‚ü®‚ü®‚ü®Y‚ü©, ‚ü®Y‚ü©‚ü©, ‚ü®œà‚ÇÇ W w hw ‚â´ œà‚ÇÅ W w, ùüô _‚ü©‚ü©, }

variable {W}
def belongs_to {A B : paths (preloc W)} (f g : A ‚ü∂ B) {D : Type*} (relations : D ‚Üí F W) : Prop :=
‚àÉ (r : D), relations r = ‚ü®‚ü®A, B‚ü©, ‚ü®f, g‚ü©‚ü©

variable (W)
def relations : hom_rel (paths (preloc W)) :=
Œª X Y f g, belongs_to f g (relations‚ÇÄ W) ‚à® belongs_to f g (relations‚ÇÅ W) ‚à®
  belongs_to f g (relations‚ÇÇ W) ‚à® belongs_to f g (relations‚ÇÉ W)

def localization : Type u := category_theory.quotient (relations W)


instance : category.{max u v} (localization W) := (infer_instance : category (category_theory.quotient (relations W)))

def Q : C ‚•§ localization W :=
{ obj := Œª X, (quotient.functor (relations W)).obj (œÜ W X),
  map := Œª X Y f, (quotient.functor (relations W)).map (œà‚ÇÅ W f),
  map_id' := Œª X, begin
    apply quotient.sound (relations W),
    exact or.inl ‚ü®X, rfl‚ü©,
  end,
  map_comp' := Œª X Y Z f g, begin
    apply quotient.sound (relations W),
    exact or.inr (or.inl (‚ü®œÅ‚ÇÅ W f g, rfl‚ü©)),
  end }

variable {W}

def Winv {X Y : C} (g : X ‚ü∂ Y) (hg : W X Y g) : (Q W).obj Y ‚ü∂ (Q W).obj X :=
(quotient.functor (relations W)).map (œà‚ÇÇ W g hg)

def Wiso {X Y : C} (g : X ‚ü∂ Y) (hg : W X Y g) : iso ((Q W).obj X) ((Q W).obj Y) :=
{ hom := (Q W).map g,
  inv := Winv g hg,
  hom_inv_id' := begin
    erw ‚Üê (quotient.functor (relations W)).map_comp (œà‚ÇÅ W g) (œà‚ÇÇ W g hg),
    apply quotient.sound (relations W),
    exact or.inr (or.inr (or.inl ‚ü®œÅ‚ÇÇ‚ÇÉ W g hg, rfl‚ü©)),
  end,
  inv_hom_id' := begin
    erw ‚Üê (quotient.functor (relations W)).map_comp (œà‚ÇÇ W g hg) (œà‚ÇÅ W g),
    apply quotient.sound (relations W),
    exact or.inr (or.inr (or.inr ‚ü®œÅ‚ÇÇ‚ÇÉ W g hg, rfl‚ü©)),
  end }

omit W

lemma congr_obj {D‚ÇÅ D‚ÇÇ : Type*} [category D‚ÇÅ] [category D‚ÇÇ] {F G : D‚ÇÅ ‚•§ D‚ÇÇ}
(h : F = G) : ‚àÄ X : D‚ÇÅ, F.obj X = G.obj X :=
by { intro X, rw h, }

lemma congr_map_conjugate {D‚ÇÅ D‚ÇÇ : Type*} [category D‚ÇÅ] [category D‚ÇÇ] {F G : D‚ÇÅ ‚•§ D‚ÇÇ}
(h : F = G) {X Y : D‚ÇÅ} (f : X ‚ü∂ Y) : F.map f =
eq_to_hom (by rw h) ‚â´ G.map f ‚â´ eq_to_hom (by rw h) :=
by { subst h, erw [id_comp, comp_id], }

lemma congr_map {D D' : Type*} [category D] [category D'] (F : D ‚•§ D')
{X Y : D} {f g : X ‚ü∂ Y} (h : f = g) : F.map f = F.map g :=
by { subst h, }

noncomputable def lift_quiver {D : Type*} [category D] (G : C ‚•§ D) (hG : W.is_inverted_by G) :
  prefunctor (preloc W) D :=
{ obj := by { rintro ‚ü®X‚ü©, exact G.obj X, },
  map := begin
    rintros ‚ü®X‚ü© ‚ü®Y‚ü© (f|‚ü®g, hg‚ü©),
    { exact G.map f, },
    { haveI : is_iso (G.map g) := hG _ _ g hg,
      exact inv (G.map g), },
  end }

@[simp]
lemma lift_quiver_map_œà‚ÇÅ {D : Type*} [category D] (G : C ‚•§ D) (hG : W.is_inverted_by G)
  {X Y : C} (f : X ‚ü∂ Y) : (Quiv.lift (lift_quiver G hG)).map (œà‚ÇÅ W f) = G.map f:=
by { dsimp [lift_quiver, œà‚ÇÅ, quiver.hom.to_path], simpa only [id_comp], }

lemma lift_quiver_map_œà‚ÇÇ {D : Type*} [category D] (G : C ‚•§ D) (hG : W.is_inverted_by G)
  {X Y : C} (g : X ‚ü∂ Y) (hg : W _ _ g) : (Quiv.lift (lift_quiver G hG)).map (œà‚ÇÇ W g hg) = 
  (by { haveI : is_iso (G.map g) := hG _ _ g hg, exact inv (G.map g), }) :=
begin
  sorry
end

noncomputable def lift {D : Type*} [category D] (G : C ‚•§ D) (hG : W.is_inverted_by G) :
  localization W ‚•§ D :=
begin
  apply quotient.lift (relations W) (Quiv.lift (lift_quiver G hG)),
  { rintro ‚ü®X‚ü© ‚ü®Y‚ü© f f' r,
    rcases r with (_|_|_|_),
    { rcases r with ‚ü®X', r‚ü©,
      have eq‚ÇÅ := congr_arg sigma.fst r,
      have eqX : X = X' := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).1.symm,
      have eqY : X' = Y := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).2,
      substs eqX eqY,
      have eq‚ÇÇ := eq_of_heq (sigma.mk.inj r).2,
      rw [‚Üê (prod.mk.inj eq‚ÇÇ).1, ‚Üê (prod.mk.inj eq‚ÇÇ).2],
      simpa only [lift_quiver_map_œà‚ÇÅ, functor.map_id], },
    { rcases r with ‚ü®‚ü®‚ü®X',‚ü®Z, Y'‚ü©‚ü©, ‚ü®g,g'‚ü©‚ü©, r‚ü©,
      have eq‚ÇÅ := congr_arg sigma.fst r,
      have eqX : X = X' := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).1.symm,
      have eqY : Y = Y' := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).2.symm,
      substs eqX eqY,
      have eq‚ÇÇ := eq_of_heq (sigma.mk.inj r).2,
      rw [‚Üê (prod.mk.inj eq‚ÇÇ).1, ‚Üê (prod.mk.inj eq‚ÇÇ).2],
      simp only [functor.map_comp, lift_quiver_map_œà‚ÇÅ], },
    { rcases r with ‚ü®‚ü®‚ü®X', Z‚ü©, ‚ü®w, hw‚ü©‚ü©, r‚ü©,
      have eq‚ÇÅ := congr_arg sigma.fst r,
      have eqX : X = X' := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).1.symm,
      have eqY : X' = Y := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).2,
      substs eqX eqY,
      have eq‚ÇÇ := eq_of_heq (sigma.mk.inj r).2,
      rw [‚Üê (prod.mk.inj eq‚ÇÇ).1, ‚Üê (prod.mk.inj eq‚ÇÇ).2],
      simp only [functor.map_comp, functor.map_id, lift_quiver_map_œà‚ÇÅ, lift_quiver_map_œà‚ÇÇ,
        is_iso.hom_inv_id], },
    { rcases r with ‚ü®‚ü®‚ü®Z, X'‚ü©, ‚ü®w, hw‚ü©‚ü©, r‚ü©,
      have eq‚ÇÅ := congr_arg sigma.fst r,
      have eqX : X = X' := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).1.symm,
      have eqY : X' = Y := congr_arg preloc.as (prod.mk.inj eq‚ÇÅ).2,
      substs eqX eqY,
      have eq‚ÇÇ := eq_of_heq (sigma.mk.inj r).2,
      rw [‚Üê (prod.mk.inj eq‚ÇÇ).1, ‚Üê (prod.mk.inj eq‚ÇÇ).2],
      simp only [functor.map_comp, functor.map_id, lift_quiver_map_œà‚ÇÅ, lift_quiver_map_œà‚ÇÇ,
        is_iso.inv_hom_id], }, },
end

lemma uniq {D : Type*} [category D] (G‚ÇÅ G‚ÇÇ : localization W ‚•§ D) (h : Q W ‚ãô G‚ÇÅ = Q W ‚ãô G‚ÇÇ) : G‚ÇÅ = G‚ÇÇ :=
begin
  suffices h' : (quotient.functor (relations W)) ‚ãô G‚ÇÅ = (quotient.functor (relations W)) ‚ãô G‚ÇÇ,
  { apply functor.ext,
    { rintros ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©,
      convert congr_map_conjugate h' f, },
    { rintro ‚ü®‚ü®X‚ü©‚ü©,
      convert congr_obj h X, }, },
  { apply paths.ext_functor,
    { rintro ‚ü®X‚ü© ‚ü®Y‚ü© f,
      cases f,
      { convert congr_map_conjugate h f, },
      { rcases f with ‚ü®g, hg‚ü©,
        dsimp at *,
        sorry, }, },
    { ext X,
      cases X,
      have eq := congr_obj h X,
      dsimp at ‚ä¢ eq,
      convert eq, }, },
end

theorem localisation_is_localisation : is_localization' (Q W) W :=
{ inverts_W := Œª X Y g hg, is_iso.of_iso (Wiso g hg),
  lift := begin
    intro D,
    introI,
    intros G hG,
    have foo := lift G hG,
    sorry,
  end,
/-  lift := Œª D, begin
    introI,
    intros G hG,
    have foo := @lift C infer_instance W,
    sorry,
  end,
  fac := sorry,-/
  uniq := Œª D, by { introI, exact uniq, } }

end category_theory
